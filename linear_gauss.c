/* 
* 
* Copyright (c) 2011,武汉大学国家多媒体中心 
* All rights reserved. 
* 
* 文件名称：SolutionLinearEquation.cpp 
* 摘要：列主元素高斯消元法解n元一次方程组 
* 
* 当前版本：1.0 
* 作者：王汪 
* 完成日期：2011年9月10日 
* 
*/  
  
#include <stdio.h>  
#include <math.h>  

#define RANK	16
  
/* 
 * 功能:选取列主元素 
 * 输入:A[]       系数矩阵A； 
 *      B[]     常数列向量B； 
 *      A_Rows  系数矩阵A的行数； 
 *      Kst_Row 待求的第k行列主元素 
 * 输出:void 
 */  
void ColumnPrimaryElement(double A[], double B[], int A_Rows, int Kst_Row)  
{  
    // 用于存放列主元素的值  
    double main_element = 0.0;  
    // 用于存放列主元素所在行  
    int main_line = 0;  
  
    // 中间变量，用于交换  
    double temp = 0.0;  
    // 循环变量  
    int i, j;  
  
    // 暂定A[k, k]为列主元素  
    main_element = A[Kst_Row * A_Rows + Kst_Row];  
    main_line = Kst_Row;  
  
    for (i = Kst_Row + 1; i < A_Rows; ++i)  
    {  
        if (fabs(A[i * A_Rows + Kst_Row]) > fabs(main_element))  
        {  
            main_element = A[i * A_Rows + Kst_Row];  
            main_line = i;  
        }  
  
        // 如果第k列元素中绝对值最大的不是a[k，k]，则交换两个方程  
        if (main_line != Kst_Row)  
        {  
            for (j = Kst_Row; j < A_Rows; ++j)  
            {  
                temp = A[Kst_Row * A_Rows + j];  
                A[Kst_Row * A_Rows + j] = A[main_line * A_Rows + j];  
                A[main_line * A_Rows + j] = temp;  
            }  
  
            temp = B[Kst_Row];  
            B[Kst_Row] = B[main_line];  
            B[main_line] = temp;  
        }  
    }  
}  
  
/* 
 * 功能:列主元素高斯消元法解n元一次方程组 
 * 输入:A[]       系数矩阵A； 
 *      B[]     常数列向量B； 
 *      A_Rows  系数矩阵A的行数； 
 * 输出:X[]       结果向量 
 */  
  
void Gauss_ColumnPrimaryElement(double A[], double B[], int A_Rows, double X[])  
{  
    // 循环变量  
    int i, j, k;  
    // 高斯消元比例因子  
    double c;  
  
    // 消元  
    for (k = 0; k < A_Rows; ++k)  
    {  
        // 选取列主元素  
        ColumnPrimaryElement(A, B, A_Rows, k);  
        for (i = k + 1; i < A_Rows; ++i)  
        {  
            // 求得高斯消元比例因子  
            c = A[i * A_Rows + k] / A[k * A_Rows + k];  
  
            for (j = k + 1; j < A_Rows; ++j)  
            {  
                A[i * A_Rows + j] = A[i * A_Rows + j] - A[k * A_Rows + j] * c;  
            }  
            B[i] = B[i] - B[k] * c;   
        }  
    }  
  
    // 有解条件判断  
    // 系数矩阵A的秩等于A的维数n(即行数或者列数)  
    if (fabs(A[(A_Rows - 1) * A_Rows + (A_Rows - 1)]) < 10e-6)  
    {  
        // 不存在唯一解  
        printf("不存在唯一解!\n");  
  
        for (i = 0; i < A_Rows; ++i)  
        {  
            X[i] = 0.0;  
        }  
        return;  
    }  
  
    // 回代求解  
    for (i = A_Rows -1; i >= 0; --i)  
    {  
        X[i] = B[i];  
        for (j = i + 1; j < A_Rows; ++j)  
        {  
            X[i] = X[i] - A[i * A_Rows + j] * X[j];  
        }  
        X[i] = X[i] / A[i * A_Rows + i];  
    }  
}  
  
void main()  
{  
    double A[RANK][RANK] =   
    {  
//        {0.2368, 0.2471, 0.2568, 1.2671, 2.587},  
//        {0.1968, 0.2071, 1.2168, 0.2271},  
//        {0.1581, 1.1675, 0.1768, 0.1871},  
//        {1.1161, 0.1254, 0.1397, 0.1490},  
	0.1370,   -2.4969,    1.8586,   -1.4694,    0.9407,   -1.4831,   -0.3086,   -2.1860,   -0.0628,   -0.5933,   -0.1318,    0.9105,   -0.2185,    0.2458,   -0.2130,    2.0034,
   -0.2919,    0.4413,   -0.6045,    0.1922,    0.7873,   -1.0203,   -1.0966,   -1.3270,   -2.0220,    0.4013,    0.5954,    0.8671,    0.5413,    0.0700,  -0.8657,    0.9510,
    0.3018,   -1.3981,    0.1034,   -0.8223,   -0.8759,   -0.4470,   -0.4930,   -1.4410,   -0.9821,    0.9421,    1.0468,   -0.0799,    0.3893,   -0.6086,   -1.0431,   -0.4320,
    0.3999,   -0.2551,    0.5632,   -0.0942,    0.3199,    0.1097,   -0.1807,    0.4018,    0.6125,    0.3005,   -0.1980,    0.8985,    0.7512,   -1.2226,   -0.2701,    0.6489,
   -0.9300,    0.1644,   0.1136,    0.3362,   -0.5583,   1.1287,    0.0458,    1.4702,   -0.0549,   -0.3731,    0.3277,    0.1837,    1.7783,    0.3165,   -0.4381,   -0.3601,
   -0.1768,    0.7477,   -0.9047,   -0.9047,  -0.3114,   -0.2900,   -0.0638,   -0.3268,   -1.1187,    0.8155,   -0.2383,    0.2908,    1.2231,   -1.3429,   -0.4087,    0.7059,
   -2.1321,   -0.2730,   -0.4677,   -0.2883,   -0.5700,    1.2616,    0.6113,    0.8123,   -0.6264,    0.7989,    0.2296,    0.1129,   -1.2833,   -1.0322,    0.9835,   1.4158,
    1.1454,    1.5763,   -0.1249,    0.3501,   -1.0257,    0.4754,    0.1093,    0.5455,    0.2495,    0.1202,    0.4400,    0.4400,   -2.3290,    1.3312,   -0.2977,   -1.6045,
   -0.6291,   -0.4809,    1.4790,   -1.8359,   -0.9087,    1.1741,    1.8140,   -1.0516,   -0.9930,    0.5712,   -0.6169,    0.1017,    0.9019,   -0.4189,    1.1437,    1.0289,
   -1.2038,    0.3275,   -0.8608,    1.0360,   -0.2099,    0.1269,    0.3120,    0.3975,    0.9750,    0.4128,    0.2748,    2.7873,   -1.8356,   -0.1403,   -0.5316,    1.4580,
   -0.2539,    0.6647,    0.7847,    2.4245,   -1.6989,   -0.6568,    1.8045,   -0.7519,   -0.6407,   -0.9870,    0.6011,   -1.1667,    0.0668,    0.8998,    0.9726,    0.0475,
   -1.4286,    0.0852,    0.3086,    0.9594,    0.6076,   -1.4814,   -0.7231,    1.5163,    1.8089,    0.7596,    0.0923,   -1.8543,    0.0355,   -0.3001,   -0.5223,    1.7463,
   -0.0209,    0.8810,   -0.2339,   -0.3158,   -0.1178,   0.1555,    0.5265,   -0.0326,   -1.0799,   -0.6572,    1.7298,   -1.1407,    2.2272,    1.0294,    0.1766,    0.1554,
   -0.5607,   0.3232,   -1.0570,    0.4286,    0.6992,    0.8186,  -0.2603,    1.6360,    0.1992,   -0.6039,   -0.6086,   -1.0933,   -0.0692,   -0.3451,    0.9707,   -1.2371,
    2.1778,   -0.7841,   -0.2841,   -1.0360,    0.2696,   -0.2926,    0.6001,   -0.4251,   -1.5210,    0.1769,   -0.7371,   -0.4336,   -0.5073,    1.0128,   -0.4140,   -2.1935,
    1.1385,   -1.8054,   -0.0867,    1.8779,    0.4943,   -0.5408,    0.5939,    0.5894,   -0.7236,   -0.3075,   -1.7499,   -0.1685,    0.2358,    0.6293,  -0.4383,  -0.3334,       
  };  
  
    double B[RANK] =   
    {  
		0.398362846165994,
		0.883969890234671,
		0.180257693987047,
		0.550854522057470,
		0.682964276111937,
		1.17060866003560,
		0.475860587278343,
		1.41223268644450,
		0.0226084843095981,
		-0.0478694102202059,
		1.70133465427496,
		-0.509711712767427,
		-0.00285496014432121,
		0.919867079806396,
		0.149808732632761,
		1.40493344567698,
    };  
  
    double X[RANK];  
  
    int i = 0;  
  
    Gauss_ColumnPrimaryElement(A[0], B, RANK, X);  
  
    printf("The result is x = \n");  
    for (i = 0; i < RANK; ++i)  
    {  
        printf("%10.6lf\n", X[i]);  
    }  
    system("pause");
}  
//MATLAB test
// A = randn(16,16)
// B = randn(16, 1)  
// MATLAB测试  
// A = [[0.2368, 0.2471, 0.2568, 1.2671];[0.1968, 0.2071, 1.2168, 0.2271];[0.1581, 1.1675, 0.1768, 0.1871];[1.1161, 0.1254, 0.1397, 0.1490]]  
// B = [1.8471; 1.7471; 1.6471; 1.5471]  
// A \ B  
